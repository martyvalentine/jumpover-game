#
# Python module cpc_random32
#
# Reproduction of the Locomotive BASIC (Amstrad CPC)
#   random number generator
#
# by Marty Valentine, 2021
#
# This code is based on the commented disassembly of the Z80 machine code
#   http://www.cpcwiki.eu/index.php/Programming:CPC_OS_floating_point_routines
#   see the included file: 
#     `documentation/CPC_OS_floating_point_routines.txt`
#
# The Amstrad Locomotive Basic random number generator is part of the 
# floating-point routines in the Amstrad CPC firmwares, 
# by Locomotive Software. More info on floating-point encoding 
# (basically, 40-bit floating point) in the CPC:
#   https://mfukar.github.io/2015/10/29/amstrad-fp.html
#   see the local copy in `documentation/`
#
# The random number generator is basically 32 bit (integer)
# which is finally converted to floating point with 2^0 exponent
# (in practice this is simply dividing by 2^32)
#
# The results of the Python code in this module have been tested
# manually (extensively, but not exhaustively) against the CPC
# Locomotive results (Amstrad CPC6128 FR running on SugarBox 1.99)
#   https://github.com/Tom1975/SugarboxV2
#
#
# Usage
# =====
# from cpc_random32 import randomize0, rnd
#
#
# To do
# =====
# TODO: implement RANDOMIZE n [value other than 0]
# TODO: CHECK: defint => int(rnd(1)+0.5) ? (probably yes)


# this module uses module-global variables

_rand32 = 0x89656c07 # initial seed

hl = 0xffff  # Z80 HL register
de = 0xffff  # Z80 DE register
bc = 0xffff  # Z80 BC register
a = 0xff     # Z80 accumulator
c = False    # Z80 carry bit
stack = []   # Z80 FIFO stack (PUSH, POP)



def randomize0():
    """Re-initialize random generator (set initial seed).
    
    This is identical to Amstrad CPC BASIC command:
      `RANDOMIZE 0`
    """
    global _rand32
    
    _rand32 = 0x89656c07
    
    
    
def rnd(j):
    """Get number from random generator (0.0 <= number < 1.0)
    
    This is identical to Amstrad CPC BASIC function:
       RND(j)
       
    With j == 0: return current random number, do not move to next 
                 number
    With j > 0 : generate next number, then return it
    With j < 0 : On Amstrad CPC, this seems to to be equivalent to 
                 `RANDOMIZE 0` followed by `RND(1)`
                 It yields 0.271940658, and reinitializes the random
                 sequence. 
                 The current implementation is still experimental,
                 but seems to work. Further testing may be needed.

    The random number sequence is identical to the one generated by
    Amstrad CPC BASIC.
    """
    global _rand32
    
    if (j < 0):
        randomize0()
        next_rnd()    
    elif (j > 0):
        next_rnd()
    rndfloat = _rand32/(2**32)
    return rndfloat



def next_rnd():
    """Utility function: generate next random number
    
    """
    global _rand32
    global hl, de, bc, a
    global c
    hl = _rand32 // 0x10000 # get MS octets to hl
    bc = 0x6c07
    call_l319c()
    stack.append(hl)
    hl = _rand32 & 0xffff # get LS octets to hl
    bc = 0x8965
    call_l319c()
    stack.append(de)
    stack.append(hl)
    hl = _rand32 // 0x10000 # get MS octets to hl
    call_l319c()
    # ex (sp),hl
    temp = stack.pop()
    stack.append(hl)
    hl = temp
    add_hl_bc()
    resultLSW = hl
    hl = stack.pop()
    bc = 0x6c07
    adc_hl_bc()
    bc = stack.pop()
    add_hl_bc()
    bc = stack.pop()
    add_hl_bc()
    resultMSW = hl
    assert_registers_OK()
    assert len(stack)==0 # check that everything went cleanly
    _rand32 = resultLSW + resultMSW*0x10000
 
def call_l319c():
    global hl, de, bc, a
    global c
    de, hl = hl, de
    hl = 0x0000
    a = 0x11
    while True:
        a -= 1
        if a==0:
            break
        add_hl_hl()
        de *= 2 # shift DE left
        if c:
            de += 1 # get old carry on the right
        # update carry
        if de > 0xFFFF:
            de -= 0x10000
            c = True
        else:
            c = False
        if not c:
            continue
        add_hl_bc()
        if not c:
            continue
        de += 1
        if de > 0xFFFF:
            de -= 0x10000
            c = True
        else:
            c = False
    assert_registers_OK()

def add_hl_hl():
    global hl, c
    hl += hl
    if hl > 0xFFFF:
        hl -= 0x10000
        c = True
    else:
        c = False
    assert_registers_OK()

def add_hl_bc():
    global hl, bc, c
    hl += bc
    if hl > 0xFFFF:
        hl -= 0x10000
        c = True
    else:
        c = False
    assert_registers_OK()

def adc_hl_bc():
    global hl, bc, c
    hl += bc
    if c:
        hl += 1
    if hl > 0xFFFF:
        hl -= 0x10000
        c = True
    else:
        c = False
    assert_registers_OK()

def assert_registers_OK():
    """just to make sure"""
    assert type(a) == int
    assert type(bc) == int
    assert type(de) == int
    assert type(hl) == int
    assert (not(bc < 0)) and (not(bc > 0xffff))
    assert (not(de < 0)) and (not(de > 0xffff))
    assert (not(hl < 0)) and (not(hl > 0xffff))
    assert (not(a < 0)) and (not(a > 0xff))
    


# testing and demonstration code
if __name__=="__main__":
    randomize0()
    n=0
    print(n,rnd(0))
    n+=1
    for i in range(10):
        print(n,rnd(1))
        n+=1
    print('(... 10000 iterations ...)')
    for i in range(1,10001):
        x = rnd(1)
        n+=1
    for i in range(1,11):
        print(n,rnd(1))
        n+=1
    
